<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Google Maps App</title>

    <script src="http://maps.googleapis.com/maps/api/js"></script>
    <script>
    function initialize() {
      var mapProp = {
        center:new google.maps.LatLng(51.508742,-0.120850),
        zoom:5,
        mapTypeId:google.maps.MapTypeId.ROADMAP
    };
    var map=new google.maps.Map(document.getElementById("googleMap"),mapProp);
}
google.maps.event.addDomListener(window, 'load', initialize);
</script>

</head>
<body>

    <div id="googleMap" style="width:500px;height:380px;">

    </div>

    <iframe src="https://maps.googleapis.com/maps/api/distancematrix/json?origins=New+Delhi
    &destinations=Gurgaon+India"></iframe>


    "public class GoogleMapsRapidExtractor {<br />
<br />
   // Given symbol, get HTML<br />
    private static String readHTML(String origin, String destination) {<br />
        In page = new In("https://maps.googleapis.com/maps/api/distancematrix/xml?origins="<br />
                             + origin + "&destinations=" + destination);<br />
        String html = page.readAll();<br />
        <br />
        String distanceAndTime = convert(html, origin, destination);<br />
        return distanceAndTime;<br />
    }<br />
    <br />
    private static String convert(String wholeText, String origin, String destination) {<br />
        <br />
        // strings that indicate what surrounds relevant text we need<br />
        // which is in this case the distance and time<br />
        String delimiterBeg = "<text>";<br />
        String delimiterEnd = "</text>";<br />
        <br />
        // finds the index of where the relevant text markers begin for time<br />
        int timeIndexBeg = wholeText.indexOf(delimiterBeg) + delimiterBeg.length();<br />
        int timeIndexEnd = wholeText.indexOf(delimiterEnd);<br />
        <br />
        // finds the index of where the relevant text markers begin for distance<br />
        int distIndexBeg = wholeText.indexOf(delimiterBeg, timeIndexBeg + 1) + delimiterBeg.length();<br />
        int distIndexEnd = wholeText.indexOf(delimiterEnd, timeIndexEnd + 1);<br />
        <br />
        <br />
        String time;<br />
        String distance;<br />
        <br />
        if (timeIndexBeg < 0 || timeIndexEnd < 0)<br />
        {<br />
            time = "ERROR";<br />
            distance = "ERROR";<br />
        }<br />
        else<br />
        {<br />
            time = wholeText.substring(timeIndexBeg,timeIndexEnd);<br />
            distance = wholeText.substring (distIndexBeg, distIndexEnd);<br />
        }<br />
<br />
        return origin + ";" + destination + ";" + time + ";" + distance;<br />
    }<br />
    <br />
    public static void main(String[] args) {<br />
        <br />
        System.out.println("Origin;Location;Time;Distance");<br />
        <br />
        while (!StdIn.isEmpty())<br />
        {<br />
            String origin = StdIn.readString();<br />
            String destination = StdIn.readString();<br />
            System.out.println(readHTML(origin, destination));<br />
        }<br />
    }<br />
}"

<br>
<br>

"/*************************************************************************<br />
 *  Compilation:  javac In.java<br />
 *  Execution:    java In   (basic test --- see source for required files)<br />
 *  Dependencies: none<br />
 *<br />
 *  Reads in data of various types from standard input, files, and URLs.<br />
 *<br />
 *************************************************************************/<br />
<br />
import java.io.BufferedInputStream;<br />
import java.io.File;<br />
import java.io.IOException;<br />
import java.io.InputStream;<br />
import java.net.URL;<br />
// import java.net.HttpURLConnection;<br />
import java.net.URLConnection;<br />
import java.util.ArrayList;<br />
import java.util.InputMismatchException;<br />
import java.util.Locale;<br />
import java.util.NoSuchElementException;<br />
import java.util.Scanner;<br />
import java.util.regex.Pattern;<br />
<br />
/**<br />
 *  &lt;i&gt;Input&lt;/i&gt;. This class provides methods for reading strings<br />
 *  and numbers from standard input, file input, URLs, and sockets. <br />
 *  &lt;p&gt;<br />
 *  The Locale used is: language = English, country = US. This is consistent<br />
 *  with the formatting conventions with Java floating-point literals,<br />
 *  command-line arguments (via {@link Double#parseDouble(String)})<br />
 *  and standard output. <br />
 *  &lt;p&gt;<br />
 *  For additional documentation, see <br />
 *  &lt;a href=&quot;http://introcs.cs.princeton.edu/31datatype&quot;&gt;Section 3.1&lt;/a&gt; of<br />
 *  &lt;i&gt;Introduction to Programming in Java: An Interdisciplinary Approach&lt;/i&gt; <br />
 *  by Robert Sedgewick and Kevin Wayne.<br />
 *  &lt;p&gt;<br />
 *  Like {@link Scanner}, reading a token also consumes preceding Java<br />
 *  whitespace, reading a full line consumes<br />
 *  the following end-of-line delimeter, while reading a character consumes<br />
 *  nothing extra. <br />
 *  &lt;p&gt;<br />
 *  Whitespace is defined in {@link Character#isWhitespace(char)}. Newlines<br />
 *  consist of n, r, rn, and Unicode hex code points 0x2028, 0x2029, 0x0085;<br />
 *  see &lt;tt&gt;&lt;a href=&quot;http://www.docjar.com/html/api/java/util/Scanner.java.html&quot;&gt;<br />
 *  Scanner.java&lt;/a&gt;&lt;/tt&gt; (NB: Java 6u23 and earlier uses only r, r, rn).<br />
 *<br />
 *  @author David Pritchard<br />
 *  @author Robert Sedgewick<br />
 *  @author Kevin Wayne<br />
 */<br />
public final class In {<br />
    <br />
    /*** begin: section (1 of 2) of code duplicated from In to StdIn. */<br />
    <br />
    // assume Unicode UTF-8 encoding<br />
    private static final String CHARSET_NAME = &quot;UTF-8&quot;;<br />
<br />
    // assume language = English, country = US for consistency with System.out.<br />
    private static final Locale LOCALE = Locale.US;<br />
<br />
    // the default token separator; we maintain the invariant that this value <br />
    // is held by the scanner's delimiter between calls<br />
    private static final Pattern WHITESPACE_PATTERN<br />
        = Pattern.compile(&quot;p{javaWhitespace}+&quot;);<br />
<br />
    // makes whitespace characters significant <br />
    private static final Pattern EMPTY_PATTERN<br />
        = Pattern.compile(&quot;&quot;);<br />
<br />
    // used to read the entire input. source:<br />
    // http://weblogs.java.net/blog/pat/archive/2004/10/stupid_scanner_1.html<br />
    private static final Pattern EVERYTHING_PATTERN<br />
        = Pattern.compile(&quot;A&quot;);<br />
<br />
    /*** end: section (1 of 2) of code duplicated from In to StdIn. */<br />
<br />
    private Scanner scanner;<br />
<br />
   /**<br />
     * Create an input stream from standard input.<br />
     */<br />
    public In() {<br />
        scanner = new Scanner(new BufferedInputStream(System.in), CHARSET_NAME);<br />
        scanner.useLocale(LOCALE);<br />
    }<br />
<br />
   /**<br />
     * Create an input stream from a socket.<br />
     */<br />
    public In(java.net.Socket socket) {<br />
        try {<br />
            InputStream is = socket.getInputStream();<br />
            scanner = new Scanner(new BufferedInputStream(is), CHARSET_NAME);<br />
            scanner.useLocale(LOCALE);<br />
        }<br />
        catch (IOException ioe) {<br />
            System.err.println(&quot;Could not open &quot; + socket);<br />
        }<br />
    }<br />
<br />
   /**<br />
     * Create an input stream from a URL.<br />
     */<br />
    public In(URL url) {<br />
        try {<br />
            URLConnection site = url.openConnection();<br />
            InputStream is     = site.getInputStream();<br />
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);<br />
            scanner.useLocale(LOCALE);<br />
        }<br />
        catch (IOException ioe) {<br />
            System.err.println(&quot;Could not open &quot; + url);<br />
        }<br />
    }<br />
<br />
   /**<br />
     * Create an input stream from a file.<br />
     */<br />
    public In(File file) {<br />
        try {<br />
            scanner = new Scanner(file, CHARSET_NAME);<br />
            scanner.useLocale(LOCALE);<br />
        }<br />
        catch (IOException ioe) {<br />
            System.err.println(&quot;Could not open &quot; + file);<br />
        }<br />
    }<br />
<br />
<br />
   /**<br />
     * Create an input stream from a filename or web page name.<br />
     */<br />
    public In(String s) {<br />
        try {<br />
            // first try to read file from local file system<br />
            File file = new File(s);<br />
            if (file.exists()) {<br />
                scanner = new Scanner(file, CHARSET_NAME);<br />
                scanner.useLocale(LOCALE);<br />
                return;<br />
            }<br />
<br />
            // next try for files included in jar<br />
            URL url = getClass().getResource(s);<br />
<br />
            // or URL from web<br />
            if (url == null) {<br />
                url = new URL(s);<br />
            }<br />
<br />
            URLConnection site = url.openConnection();<br />
<br />
            // in order to set User-Agent, replace above line with these two<br />
            // HttpURLConnection site = (HttpURLConnection) url.openConnection();<br />
            // site.addRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.76&quot;);<br />
<br />
            InputStream is     = site.getInputStream();<br />
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);<br />
            scanner.useLocale(LOCALE);<br />
        }<br />
        catch (IOException ioe) {<br />
            System.err.println(&quot;Could not open &quot; + s);<br />
        }<br />
    }<br />
<br />
    /**<br />
     * Create an input stream from a given Scanner source; use with <br />
     * &lt;tt&gt;new Scanner(String)&lt;/tt&gt; to read from a string.<br />
     * &lt;p&gt;<br />
     * Note that this does not create a defensive copy, so the<br />
     * scanner will be mutated as you read on. <br />
     */<br />
    public In(Scanner scanner) {<br />
        this.scanner = scanner;<br />
    }<br />
<br />
    /**<br />
     * Does the input stream exist?<br />
     */<br />
    public boolean exists()  {<br />
        return scanner != null;<br />
    }<br />
    <br />
    /*** begin: section (2 of 2) of code duplicated from In to StdIn,<br />
      *  with all methods changed from &quot;public&quot; to &quot;public static&quot;. ***/<br />
<br />
   /**<br />
     * Is the input empty (except possibly for whitespace)? Use this<br />
     * to know whether the next call to {@link #readString()}, <br />
     * {@link #readDouble()}, etc will succeed.<br />
     */<br />
    public boolean isEmpty() {<br />
        return !scanner.hasNext();<br />
    }<br />
<br />
   /**<br />
     * Does the input have a next line? Use this to know whether the<br />
     * next call to {@link #readLine()} will succeed. &lt;p&gt; Functionally<br />
     * equivalent to {@link #hasNextChar()}.<br />
     */<br />
    public boolean hasNextLine() {<br />
        return scanner.hasNextLine();<br />
    }<br />
<br />
    /**<br />
     * Is the input empty (including whitespace)? Use this to know <br />
     * whether the next call to {@link #readChar()} will succeed. &lt;p&gt; Functionally<br />
     * equivalent to {@link #hasNextLine()}.<br />
     */<br />
    public boolean hasNextChar() {<br />
        scanner.useDelimiter(EMPTY_PATTERN);<br />
        boolean result = scanner.hasNext();<br />
        scanner.useDelimiter(WHITESPACE_PATTERN);<br />
        return result;<br />
    }<br />
<br />
<br />
   /**<br />
     * Read and return the next line.<br />
     */<br />
    public String readLine() {<br />
        String line;<br />
        try {<br />
            line = scanner.nextLine();<br />
        }<br />
        catch (NoSuchElementException e) {<br />
            line = null;<br />
        }<br />
        return line;<br />
    }<br />
<br />
    /**<br />
     * Read and return the next character.<br />
     */<br />
    public char readChar() {<br />
        scanner.useDelimiter(EMPTY_PATTERN);<br />
        String ch = scanner.next();<br />
        assert (ch.length() == 1) : &quot;Internal (Std)In.readChar() error!&quot;<br />
            + &quot; Please contact the authors.&quot;;<br />
        scanner.useDelimiter(WHITESPACE_PATTERN);<br />
        return ch.charAt(0);<br />
    }  <br />
<br />
<br />
   /**<br />
     * Read and return the remainder of the input as a string.<br />
     */<br />
    public String readAll() {<br />
        if (!scanner.hasNextLine())<br />
            return &quot;&quot;;<br />
<br />
        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();<br />
        // not that important to reset delimeter, since now scanner is empty<br />
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway<br />
        return result;<br />
    }<br />
<br />
<br />
   /**<br />
     * Read and return the next string.<br />
     */<br />
    public String readString() {<br />
        return scanner.next();<br />
    }<br />
<br />
   /**<br />
     * Read and return the next int.<br />
     */<br />
    public int readInt() {<br />
        return scanner.nextInt();<br />
    }<br />
<br />
   /**<br />
     * Read and return the next double.<br />
     */<br />
    public double readDouble() {<br />
        return scanner.nextDouble();<br />
    }<br />
<br />
   /**<br />
     * Read and return the next float.<br />
     */<br />
    public float readFloat() {<br />
        return scanner.nextFloat();<br />
    }<br />
<br />
   /**<br />
     * Read and return the next long.<br />
     */<br />
    public long readLong() {<br />
        return scanner.nextLong();<br />
    }<br />
<br />
   /**<br />
     * Read and return the next short.<br />
     */<br />
    public short readShort() {<br />
        return scanner.nextShort();<br />
    }<br />
<br />
   /**<br />
     * Read and return the next byte.<br />
     */<br />
    public byte readByte() {<br />
        return scanner.nextByte();<br />
    }<br />
<br />
    /**<br />
     * Read and return the next boolean, allowing case-insensitive<br />
     * &quot;true&quot; or &quot;1&quot; for true, and &quot;false&quot; or &quot;0&quot; for false.<br />
     */<br />
    public boolean readBoolean() {<br />
        String s = readString();<br />
        if (s.equalsIgnoreCase(&quot;true&quot;))  return true;<br />
        if (s.equalsIgnoreCase(&quot;false&quot;)) return false;<br />
        if (s.equals(&quot;1&quot;))               return true;<br />
        if (s.equals(&quot;0&quot;))               return false;<br />
        throw new InputMismatchException();<br />
    }<br />
<br />
    /**<br />
     * Read all strings until the end of input is reached, and return them.<br />
     */<br />
    public String[] readAllStrings() {<br />
        // we could use readAll.trim().split(), but that's not consistent<br />
        // since trim() uses characters 0x00..0x20 as whitespace<br />
        String[] tokens = WHITESPACE_PATTERN.split(readAll());<br />
        if (tokens.length == 0 || tokens[0].length() &gt; 0)<br />
            return tokens;<br />
        String[] decapitokens = new String[tokens.length-1];<br />
        for (int i = 0; i &lt; tokens.length-1; i++)<br />
            decapitokens[i] = tokens[i+1];<br />
        return decapitokens;<br />
    }<br />
<br />
    /**<br />
     * Reads all remaining lines from input stream and returns them as an array of strings.<br />
     * @return all remaining lines on input stream, as an array of strings<br />
     */<br />
    public String[] readAllLines() {<br />
        ArrayList&lt;String&gt; lines = new ArrayList&lt;String&gt;();<br />
        while (hasNextLine()) {<br />
            lines.add(readLine());<br />
        }<br />
        return lines.toArray(new String[0]);<br />
    }<br />
<br />
<br />
    /**<br />
     * Read all ints until the end of input is reached, and return them.<br />
     */<br />
    public int[] readAllInts() {<br />
        String[] fields = readAllStrings();<br />
        int[] vals = new int[fields.length];<br />
        for (int i = 0; i &lt; fields.length; i++)<br />
            vals[i] = Integer.parseInt(fields[i]);<br />
        return vals;<br />
    }<br />
<br />
    /**<br />
     * Read all doubles until the end of input is reached, and return them.<br />
     */<br />
    public double[] readAllDoubles() {<br />
        String[] fields = readAllStrings();<br />
        double[] vals = new double[fields.length];<br />
        for (int i = 0; i &lt; fields.length; i++)<br />
            vals[i] = Double.parseDouble(fields[i]);<br />
        return vals;<br />
    }<br />
    <br />
    /*** end: section (2 of 2) of code duplicated from In to StdIn */<br />
    <br />
   /**<br />
     * Close the input stream.<br />
     */<br />
    public void close() {<br />
        scanner.close();  <br />
    }<br />
<br />
    /**<br />
     * Reads all ints from a file.<br />
     * @deprecated Clearer to use <br />
     * &lt;tt&gt;new In(filename)&lt;/tt&gt;.{@link #readAllInts()}<br />
     */<br />
    public static int[] readInts(String filename) {<br />
        return new In(filename).readAllInts();<br />
    }<br />
<br />
   /**<br />
     * Reads all doubles from a file.<br />
     * @deprecated Clearer to use <br />
     * &lt;tt&gt;new In(filename)&lt;/tt&gt;.{@link #readAllDoubles()}<br />
     */<br />
    public static double[] readDoubles(String filename) {<br />
        return new In(filename).readAllDoubles();<br />
    }<br />
<br />
   /**<br />
     * Reads all strings from a file.<br />
     * @deprecated Clearer to use <br />
     * &lt;tt&gt;new In(filename)&lt;/tt&gt;.{@link #readAllStrings()}<br />
     */<br />
    public static String[] readStrings(String filename) {<br />
        return new In(filename).readAllStrings();<br />
    }<br />
<br />
    /**<br />
     * Reads all ints from standard input.<br />
     * @deprecated Clearer to use {@link StdIn#readAllInts()}<br />
     */<br />
    public static int[] readInts() {<br />
        return new In().readAllInts();<br />
    }<br />
<br />
   /**<br />
     * Reads all doubles from standard input.<br />
     * @deprecated Clearer to use {@link StdIn#readAllDoubles()}<br />
     */<br />
    public static double[] readDoubles() {<br />
        return new In().readAllDoubles();<br />
    }<br />
<br />
   /**<br />
     * Reads all strings from standard input.<br />
     * @deprecated Clearer to use {@link StdIn#readAllStrings()}<br />
     */<br />
    public static String[] readStrings() {<br />
        return new In().readAllStrings();<br />
    }<br />
    <br />
   /**<br />
     * Test client.<br />
     */<br />
    public static void main(String[] args) {<br />
        In in;<br />
        String urlName = &quot;http://introcs.cs.princeton.edu/stdlib/InTest.txt&quot;;<br />
<br />
        // read from a URL<br />
        System.out.println(&quot;readAll() from URL &quot; + urlName);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(urlName);<br />
            System.out.println(in.readAll());<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
        // read one line at a time from URL<br />
        System.out.println(&quot;readLine() from URL &quot; + urlName);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(urlName);<br />
            while (!in.isEmpty()) {<br />
                String s = in.readLine();<br />
                System.out.println(s);<br />
            }<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
        // read one string at a time from URL<br />
        System.out.println(&quot;readString() from URL &quot; + urlName);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(urlName);<br />
            while (!in.isEmpty()) {<br />
                String s = in.readString();<br />
                System.out.println(s);<br />
            }<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
<br />
        // read one line at a time from file in current directory<br />
        System.out.println(&quot;readLine() from current directory&quot;);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(&quot;./InTest.txt&quot;);<br />
            while (!in.isEmpty()) {<br />
                String s = in.readLine();<br />
                System.out.println(s);<br />
            }<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
<br />
        // read one line at a time from file using relative path<br />
        System.out.println(&quot;readLine() from relative path&quot;);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(&quot;../stdlib/InTest.txt&quot;);<br />
            while (!in.isEmpty()) {<br />
                String s = in.readLine();<br />
                System.out.println(s);<br />
            }<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
        // read one char at a time<br />
        System.out.println(&quot;readChar() from file&quot;);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(&quot;InTest.txt&quot;);<br />
            while (!in.isEmpty()) {<br />
                char c = in.readChar();<br />
                System.out.print(c);<br />
            }<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
        System.out.println();<br />
<br />
        // read one line at a time from absolute OS X / Linux path<br />
        System.out.println(&quot;readLine() from absolute OS X / Linux path&quot;);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        in = new In(&quot;/n/fs/introcs/www/java/stdlib/InTest.txt&quot;);<br />
        try {<br />
            while (!in.isEmpty()) {<br />
                String s = in.readLine();<br />
                System.out.println(s);<br />
            }<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
<br />
        // read one line at a time from absolute Windows path<br />
        System.out.println(&quot;readLine() from absolute Windows path&quot;);<br />
        System.out.println(&quot;---------------------------------------------------------------------------&quot;);<br />
        try {<br />
            in = new In(&quot;G:wwwintrocsstdlibInTest.txt&quot;);<br />
            while (!in.isEmpty()) {<br />
                String s = in.readLine();<br />
                System.out.println(s);<br />
            }<br />
            System.out.println();<br />
        }<br />
        catch (Exception e) {<br />
            System.out.println(e);<br />
        }<br />
        System.out.println();<br />
<br />
    }<br />
<br />
}
"


"
/*************************************************************************<br />
 *  Compilation:  javac StdIn.java<br />
 *  Execution:    java StdIn   (interactive test of basic functionality)<br />
 *  Dependencies: none<br />
 *<br />
 *  Reads in data of various types from standard input.<br />
 *<br />
 *************************************************************************/<br />
<br />
import java.util.ArrayList;<br />
import java.util.InputMismatchException;<br />
import java.util.Locale;<br />
import java.util.NoSuchElementException;<br />
import java.util.Scanner;<br />
import java.util.regex.Pattern;<br />
<br />
/**<br />
 *  The &lt;tt&gt;StdIn&lt;/tt&gt; class provides static methods for reading strings<br />
 *  and numbers from standard input. See <br />
 *  &lt;a href=&quot;http://introcs.cs.princeton.edu/15inout&quot;&gt;Section 1.5&lt;/a&gt; of<br />
 *  &lt;i&gt;Introduction to Programming in Java: An Interdisciplinary Approach&lt;/i&gt;<br />
 *  by Robert Sedgewick and Kevin Wayne.<br />
 *  &lt;p&gt;<br />
 *  For uniformity across platforms, this class uses &lt;tt&gt;Locale.US&lt;/tt&gt;<br />
 *  for the locale and &lt;tt&gt;&quot;UTF-8&quot;&lt;/tt&gt; for the character-set encoding.<br />
 *  The English language locale is consistent with the formatting conventions<br />
 *  for Java floating-point literals, command-line arguments<br />
 *  (via {@link Double#parseDouble(String)}) and standard output.<br />
 *  &lt;p&gt;<br />
 *  Like {@link Scanner}, reading a &lt;em&gt;token&lt;/em&gt; also consumes preceding Java<br />
 *  whitespace; reading a line consumes the following end-of-line<br />
 *  delimeter; reading a character consumes nothing extra. <br />
 *  &lt;p&gt;<br />
 *  Whitespace is defined in {@link Character#isWhitespace(char)}. Newlines<br />
 *  consist of n, r, rn, and Unicode hex code points 0x2028, 0x2029, 0x0085;<br />
 *  see &lt;tt&gt;&lt;a href=&quot;http://www.docjar.com/html/api/java/util/Scanner.java.html&quot;&gt;<br />
 *  Scanner.java&lt;/a&gt;&lt;/tt&gt; (NB: Java 6u23 and earlier uses only r, r, rn).<br />
 *  &lt;p&gt;<br />
 *  See {@link In} for a version that handles input from files, URLs,<br />
 *  and sockets.<br />
 *  &lt;p&gt;<br />
 *  Note that Java's UTF-8 encoding does not recognize the optional byte-order<br />
 *  mask. If the input begins with the optional byte-order mask, &lt;tt&gt;StdIn&lt;/tt&gt;<br />
 *  will have an extra character &lt;tt&gt;uFEFF&lt;/tt&gt; at the beginning.<br />
 *  For details, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058.<br />
 *<br />
 *  @author David Pritchard<br />
 *  @author Robert Sedgewick<br />
 *  @author Kevin Wayne<br />
 */<br />
public final class StdIn {<br />
<br />
    /*** begin: section (1 of 2) of code duplicated from In to StdIn. */<br />
    <br />
    // assume Unicode UTF-8 encoding<br />
    private static final String CHARSET_NAME = &quot;UTF-8&quot;;<br />
<br />
    // assume language = English, country = US for consistency with System.out.<br />
    private static final Locale LOCALE = Locale.US;<br />
<br />
    // the default token separator; we maintain the invariant that this value<br />
    // is held by the scanner's delimiter between calls<br />
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(&quot;p{javaWhitespace}+&quot;);<br />
<br />
    // makes whitespace characters significant<br />
    private static final Pattern EMPTY_PATTERN = Pattern.compile(&quot;&quot;);<br />
<br />
    // used to read the entire input<br />
    private static final Pattern EVERYTHING_PATTERN = Pattern.compile(&quot;A&quot;);<br />
<br />
    /*** end: section (1 of 2) of code duplicated from In to StdIn. */<br />
<br />
    private static Scanner scanner;<br />
 <br />
    // it doesn't make sense to instantiate this class<br />
    private StdIn() { }<br />
<br />
    /*** begin: section (2 of 2) of code duplicated from In to StdIn,<br />
      *  with all methods changed from &quot;public&quot; to &quot;public static&quot; ***/<br />
<br />
   /**<br />
     * Is the input empty (except possibly for whitespace)? Use this<br />
     * to know whether the next call to {@link #readString()}, <br />
     * {@link #readDouble()}, etc will succeed.<br />
     * @return true if standard input is empty (except possibly<br />
     *     for whitespae), and false otherwise<br />
     */<br />
    public static boolean isEmpty() {<br />
        return !scanner.hasNext();<br />
    }<br />
<br />
   /**<br />
     * Does the input have a next line? Use this to know whether the<br />
     * next call to {@link #readLine()} will succeed. &lt;p&gt; Functionally<br />
     * equivalent to {@link #hasNextChar()}.<br />
     * @return true if standard input is empty, and false otherwise<br />
     */<br />
    public static boolean hasNextLine() {<br />
        return scanner.hasNextLine();<br />
    }<br />
<br />
    /**<br />
     * Is the input empty (including whitespace)? Use this to know <br />
     * whether the next call to {@link #readChar()} will succeed.<br />
     * &lt;p&gt;Functionally equivalent to {@link #hasNextLine()}.<br />
     * @return true if standard input is empty, and false otherwise<br />
     */<br />
    public static boolean hasNextChar() {<br />
        scanner.useDelimiter(EMPTY_PATTERN);<br />
        boolean result = scanner.hasNext();<br />
        scanner.useDelimiter(WHITESPACE_PATTERN);<br />
        return result;<br />
    }<br />
<br />
<br />
   /**<br />
     * Reads and returns the next line, excluding the line separator if present.<br />
     * @return the next line, excluding the line separator if present<br />
     */<br />
    public static String readLine() {<br />
        String line;<br />
        try {<br />
            line = scanner.nextLine();<br />
        }<br />
        catch (NoSuchElementException e) {<br />
            line = null;<br />
        }<br />
        return line;<br />
    }<br />
<br />
    /**<br />
     * Reads and returns the next character.<br />
     * @return the next character<br />
     */<br />
    public static char readChar() {<br />
        scanner.useDelimiter(EMPTY_PATTERN);<br />
        String ch = scanner.next();<br />
        assert (ch.length() == 1) : &quot;Internal (Std)In.readChar() error!&quot;<br />
            + &quot; Please contact the authors.&quot;;<br />
        scanner.useDelimiter(WHITESPACE_PATTERN);<br />
        return ch.charAt(0);<br />
    }  <br />
<br />
<br />
   /**<br />
     * Reads and returns the remainder of the input, as a string.<br />
     * @return the remainder of the input, as a string<br />
     */<br />
    public static String readAll() {<br />
        if (!scanner.hasNextLine())<br />
            return &quot;&quot;;<br />
<br />
        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();<br />
        // not that important to reset delimeter, since now scanner is empty<br />
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway<br />
        return result;<br />
    }<br />
<br />
<br />
   /**<br />
     * Reads the next token  and returns the &lt;tt&gt;String&lt;/tt&gt;.<br />
     * @return the next &lt;tt&gt;String&lt;/tt&gt;<br />
     */<br />
    public static String readString() {<br />
        return scanner.next();<br />
    }<br />
<br />
   /**<br />
     * Reads the next token from standard input, parses it as an integer, and returns the integer.<br />
     * @return the next integer on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as an &lt;tt&gt;int&lt;/tt&gt;<br />
     */<br />
    public static int readInt() {<br />
        return scanner.nextInt();<br />
    }<br />
<br />
   /**<br />
     * Reads the next token from standard input, parses it as a double, and returns the double.<br />
     * @return the next double on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;double&lt;/tt&gt;<br />
     */<br />
    public static double readDouble() {<br />
        return scanner.nextDouble();<br />
    }<br />
<br />
   /**<br />
     * Reads the next token from standard input, parses it as a float, and returns the float.<br />
     * @return the next float on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;float&lt;/tt&gt;<br />
     */<br />
    public static float readFloat() {<br />
        return scanner.nextFloat();<br />
    }<br />
<br />
   /**<br />
     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.<br />
     * @return the next long integer on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;long&lt;/tt&gt;<br />
     */<br />
    public static long readLong() {<br />
        return scanner.nextLong();<br />
    }<br />
<br />
   /**<br />
     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.<br />
     * @return the next short integer on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;short&lt;/tt&gt;<br />
     */<br />
    public static short readShort() {<br />
        return scanner.nextShort();<br />
    }<br />
<br />
   /**<br />
     * Reads the next token from standard input, parses it as a byte, and returns the byte.<br />
     * @return the next byte on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;byte&lt;/tt&gt;<br />
     */<br />
    public static byte readByte() {<br />
        return scanner.nextByte();<br />
    }<br />
<br />
    /**<br />
     * Reads the next token from standard input, parses it as a boolean,<br />
     * and returns the boolean.<br />
     * @return the next boolean on standard input<br />
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;boolean&lt;/tt&gt;:<br />
     *    &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;1&lt;/tt&gt; for true, and &lt;tt&gt;false&lt;/tt&gt; or &lt;tt&gt;0&lt;/tt&gt; for false,<br />
     *    ignoring case<br />
     */<br />
    public static boolean readBoolean() {<br />
        String s = readString();<br />
        if (s.equalsIgnoreCase(&quot;true&quot;))  return true;<br />
        if (s.equalsIgnoreCase(&quot;false&quot;)) return false;<br />
        if (s.equals(&quot;1&quot;))               return true;<br />
        if (s.equals(&quot;0&quot;))               return false;<br />
        throw new InputMismatchException();<br />
    }<br />
<br />
    /**<br />
     * Reads all remaining tokens from standard input and returns them as an array of strings.<br />
     * @return all remaining tokens on standard input, as an array of strings<br />
     */<br />
    public static String[] readAllStrings() {<br />
        // we could use readAll.trim().split(), but that's not consistent<br />
        // because trim() uses characters 0x00..0x20 as whitespace<br />
        String[] tokens = WHITESPACE_PATTERN.split(readAll());<br />
        if (tokens.length == 0 || tokens[0].length() &gt; 0)<br />
            return tokens;<br />
<br />
        // don't include first token if it is leading whitespace<br />
        String[] decapitokens = new String[tokens.length-1];<br />
        for (int i = 0; i &lt; tokens.length - 1; i++)<br />
            decapitokens[i] = tokens[i+1];<br />
        return decapitokens;<br />
    }<br />
<br />
    /**<br />
     * Reads all remaining lines from standard input and returns them as an array of strings.<br />
     * @return all remaining lines on standard input, as an array of strings<br />
     */<br />
    public static String[] readAllLines() {<br />
        ArrayList&lt;String&gt; lines = new ArrayList&lt;String&gt;();<br />
        while (hasNextLine()) {<br />
            lines.add(readLine());<br />
        }<br />
        return lines.toArray(new String[0]);<br />
    }<br />
<br />
    /**<br />
     * Reads all remaining tokens from standard input, parses them as integers, and returns<br />
     * them as an array of integers.<br />
     * @return all remaining integers on standard input, as an array<br />
     * @throws InputMismatchException if any token cannot be parsed as an &lt;tt&gt;int&lt;/tt&gt;<br />
     */<br />
    public static int[] readAllInts() {<br />
        String[] fields = readAllStrings();<br />
        int[] vals = new int[fields.length];<br />
        for (int i = 0; i &lt; fields.length; i++)<br />
            vals[i] = Integer.parseInt(fields[i]);<br />
        return vals;<br />
    }<br />
<br />
    /**<br />
     * Reads all remaining tokens from standard input, parses them as doubles, and returns<br />
     * them as an array of doubles.<br />
     * @return all remaining doubles on standard input, as an array<br />
     * @throws InputMismatchException if any token cannot be parsed as a &lt;tt&gt;double&lt;/tt&gt;<br />
     */<br />
    public static double[] readAllDoubles() {<br />
        String[] fields = readAllStrings();<br />
        double[] vals = new double[fields.length];<br />
        for (int i = 0; i &lt; fields.length; i++)<br />
            vals[i] = Double.parseDouble(fields[i]);<br />
        return vals;<br />
    }<br />
    <br />
    /*** end: section (2 of 2) of code duplicated from In to StdIn */<br />
    <br />
    <br />
    // do this once when StdIn is initialized<br />
    static {<br />
        resync();<br />
    }<br />
<br />
    /**<br />
     * If StdIn changes, use this to reinitialize the scanner.<br />
     */<br />
    private static void resync() {<br />
        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));<br />
    }<br />
    <br />
    private static void setScanner(Scanner scanner) {<br />
        StdIn.scanner = scanner;<br />
        StdIn.scanner.useLocale(LOCALE);<br />
    }<br />
<br />
   /**<br />
     * Reads all remaining tokens, parses them as integers, and returns<br />
     * them as an array of integers.<br />
     * @return all remaining integers, as an array<br />
     * @throws InputMismatchException if any token cannot be parsed as an &lt;tt&gt;int&lt;/tt&gt;<br />
     * @deprecated For more consistency, use {@link #readAllInts()}<br />
     */<br />
    public static int[] readInts() {<br />
        return readAllInts();<br />
    }<br />
<br />
   /**<br />
     * Reads all remaining tokens, parses them as doubles, and returns<br />
     * them as an array of doubles.<br />
     * @return all remaining doubles, as an array<br />
     * @throws InputMismatchException if any token cannot be parsed as a &lt;tt&gt;double&lt;/tt&gt;<br />
     * @deprecated For more consistency, use {@link #readAllDoubles()}<br />
     */<br />
    public static double[] readDoubles() {<br />
        return readAllDoubles();<br />
    }<br />
<br />
   /**<br />
     * Reads all remaining tokens and returns them as an array of strings.<br />
     * @return all remaining tokens, as an array of strings<br />
     * @deprecated For more consistency, use {@link #readAllStrings()}<br />
     */<br />
    public static String[] readStrings() {<br />
        return readAllStrings();<br />
    }<br />
<br />
<br />
    /**<br />
     * Interactive test of basic functionality.<br />
     */<br />
    public static void main(String[] args) {<br />
<br />
        System.out.println(&quot;Type a string: &quot;);<br />
        String s = StdIn.readString();<br />
        System.out.println(&quot;Your string was: &quot; + s);<br />
        System.out.println();<br />
<br />
        System.out.println(&quot;Type an int: &quot;);<br />
        int a = StdIn.readInt();<br />
        System.out.println(&quot;Your int was: &quot; + a);<br />
        System.out.println();<br />
<br />
        System.out.println(&quot;Type a boolean: &quot;);<br />
        boolean b = StdIn.readBoolean();<br />
        System.out.println(&quot;Your boolean was: &quot; + b);<br />
        System.out.println();<br />
<br />
        System.out.println(&quot;Type a double: &quot;);<br />
        double c = StdIn.readDouble();<br />
        System.out.println(&quot;Your double was: &quot; + c);<br />
        System.out.println();<br />
<br />
    }<br />
<br />
}"
</body>
</html>